package main

import "fmt"

/*
*
什么是带缓冲通道？
1、带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态。
2、也就是说发送端可以一直发送数据到缓冲区，直到缓冲区满的这段时间，发送方可以不和接收方保持同步，知道缓冲区满了就需要发送端和接收端保持实时同步。

无缓冲通道和带缓冲通道区别：
1、如果通道不带缓冲，发送方会一直阻塞直到接收方从通道中接收了值。
2、如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；

如何创建带缓冲的通道呢？参见如下代码：

	通道实例 := make(chan 通道类型, 缓冲大小)
*/
func main() {
	// 创建一个3个元素缓冲大小的整型通道
	ch := make(chan int, 3)

	// 查看当前通道的大小
	fmt.Println(len(ch))

	// 发送3个整型元素到通道，因为使用了缓冲通道。即便没有 goroutine 接收，发送者也不会发生阻塞。
	ch <- 1
	ch <- 2
	ch <- 3

	// 查看当前通道的大小
	fmt.Println(len(ch))
}

/**
为什么Go语言对通道要限制长度而不提供无限长度的通道？
1、当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。
2、因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。
*/
